// This is a test file for variable types in Rust.

/*
fn main() {
    var a: i32 = 10;
    var b: f64 = 3.14;
    print a;
    print b;

    var c: bool = true;
    print c;

    var d: str = "Hello, world!";
    print d;

    var e = null;
    print e;

    var f: Fn = |x| x + 1;
    print f(10);

    // class create default type
    class A {}
    // class B {}
    var g: A = A;       // success
    // var h: A = B;    // error: expected type `class(A)`, found type `class(B)`
    print g;

    // var i: fn(i32,i32) -> i32 = |a: i32, b: i32| -> i32 { a + b };
    // print i(1, 2);

    class Point {
        var x: i32;
        var y: i32;
    }

    var j: Point = Point();
    print j;

    j.x = 10;
    j.y = 20;
    print j;
}

main();

    // fn closure
    fn counter(name: str, n: i32) -> i32 {
        print name;
        return n + 1;
    }
    
// TODO: var type check. and fn type check. base type create instance and class create instance.
    var a: i32 = 10;
    var b: f64 = 3.14;
    var c: bool = true;
    var d: str = "Hello, world!";
    var e = null;
    var f: Fn(i32) -> i32 = |x: i32| -> i32 { 
        return x + 1;
    };

    fn counter(name: str, n: i32) -> i32 {
        print f(n);
        return n + 1;
    }

    var g: Fn(str, i32) -> i32 = counter;
    print g("Hello, world!", 10);

    var h: i32 = counter("Hello, world!", 10);
    print h;
    print f(10);

    fn local_fn() -> i32 {
        var i: i32 = 10;
        var f: Fn(i32) -> i32 = |x: i32| -> i32 {
            return x + i;
        };
        print f(20);
    }

    local_fn();

    fn used_trinomial(condition: bool) -> bool {
        // return condition ? true : 1;  // error:  Type mismatch in binary expression, left type 'bool' and right type 'i32'.
        return condition ? true : false;
    }
    var i: bool = used_trinomial(true);
    print i;

// TODO: class create and instance. handler class method and functions call. class parameter and return type.
    class Point {
        var inner_x: i32 = 10000;
        var x: i32;
        var y: i32;

        fn init(this, x: i32, y: i32) {
            this.x = x;
            this.y = y;
        }
        fn get_x(this) -> i32 {
            return this.x;
        }
        fn add_into(a: i32, b: i32) -> i32 {
            return a + b;
        }
    }

    // create class instance default call init method.
    var j: Point = Point(1000, 2000);
    print j.x;
    print j.y;

    print "get x value";
    var j_get_x: Fn(Point) -> i32 = Point.get_x;
    
    print "add into value";
    print j.add_into(10, 20);

    // setter class parameter.
    j.x = 10;
    j.y = 20;

    // getter class parameter.
    print j.x;
    print j.y;

    // show class instance.
    print j;

    // class getter class parameter.
    print Point.inner_x;

    // class function call.
    var j_add_into: Fn(i32, i32) -> i32 = Point.add_into;
    print j_add_into(10, 20);

// TODO: class inheritance. handler class super keyword resolve static check and call method.
    class Point {
        var x: i32;
        var y: i32;
        fn init(this, x: i32, y: i32) {
            this.x = x;
            this.y = y;
        }
        fn aux_display(p: Point) -> None { 
            print p.x; 
        }
    }

    class Circle: Point {
        var radius: f64;
        fn init(this, x: i32, y: i32, radius: f64) {
            super.init(x, y);
            this.radius = radius;
        }
        fn area(this) -> f64 {
            return 3.1415926 * this.radius * this.radius;
        }
    }

    var p: Point = Point(10, 20);
    var c: Circle = Circle(10, 20, 3.0);

    print p;
    print "aux_display:";
    // p.aux_display(p);
    
    print "Circle:";
    print c;
    print c.area();

// TODO: handler class this.p = this.p ... question: how to handle this.p in class method.
    class Point {
        var x: i32;
        var y: i32;
        fn init(this, x: i32, y: i32) {
            this.x = x;
            this.y = y;
        }
    }

    fn move_point(p: Point, dx: i32, dy: i32) -> None {
        // setter(getter, getter + dx)
        p.x = p.x + dx; 
        p.y = p.y + dy;
    }

    var p1: Point = Point(10, 20);
    move_point(p1, 100, 200);
    print p1;
*/

fn main() {
    var a: i32 = 10;
    var b: f64 = 3.14;
    print a;
    print b;

    var c: bool = true;
    print c;

    var d: str = "Hello, world!";
    print d;

    var e = null;
    print e;
}

main();
